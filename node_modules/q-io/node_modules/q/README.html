<p><a href="http://travis-ci.org/kriskowal/q"><img src="https://secure.travis-ci.org/kriskowal/q.png?branch=master" alt="Build Status"></a></p>
<p><a href="http://promises-aplus.github.com/promises-spec">
    <img src="http://promises-aplus.github.com/promises-spec/assets/logo-small.png"
         align="right" alt="Promises/A+ logo" />
</a></p>
<p><em>:warning: This is Q version 2 and is experimental at this time. If you install
the latest Q from <code>npm</code>, you will get the latest from the <a href="https://github.com/kriskowal/q/tree/v1">version 1</a>
release train. You will get the lastet of version 2 if you use <code>npm install
q@~2</code>. Consult <a href="https://github.com/kriskowal/q/blob/v2/CHANGES.md">CHANGES.md</a> for details on what has changed</em></p>
<p><em>Among the significant differences in version 2, the source is CommonJS only and
versions suitable for use with AMD and plain <code>&lt;script&gt;</code> tags are built and
published for <a href="http://q-releases.s3-website-us-west-1.amazonaws.com/">download</a> with each release.</em></p>
<p>If a function cannot return a value or throw an exception without
blocking, it can return a promise instead.  A promise is an object
that represents the return value or the thrown exception that the
function may eventually provide.  A promise can also be used as a
proxy for a <a href="https://github.com/kriskowal/q-connection">remote object</a> to overcome latency.</p>
<h2>Getting Started</h2><p>The Q module can be loaded as:</p>
<ul>
<li>A <code>&lt;script&gt;</code> tag (creating a <code>Q</code> global variable): ~2.5 KB minified and
gzipped.  Download the latest of <a href="https://raw.github.com/kriskowal/q/v0.9/q.js">version
0.9</a></li>
<li>A Node.js and CommonJS module, available in <a href="https://npmjs.org/">npm</a> as
the <a href="https://npmjs.org/package/q">q</a> package</li>
<li>An AMD module.  <a href="https://raw.github.com/kriskowal/q/v0.9/q.js">Download version
0.9</a></li>
<li>A <a href="https://github.com/component/component">component</a> as <code>microjs/q</code></li>
<li>Using <a href="http://bower.io/">bower</a> as <code>q</code></li>
<li>Using <a href="http://nuget.org/">NuGet</a> as <a href="https://nuget.org/packages/q">Q</a></li>
</ul>
<p>Q can exchange promises with jQuery, Dojo, When.js, WinJS, and more.</p>
<h2>Resources</h2><p>Our <a href="https://github.com/kriskowal/q/wiki">wiki</a> contains a number of useful resources, including:</p>
<ul>
<li>A method-by-method <a href="https://github.com/kriskowal/q/wiki/API-Reference">Q API reference</a>.</li>
<li>A growing <a href="https://github.com/kriskowal/q/wiki/Examples-Gallery">examples gallery</a>, showing how Q can be used to make
everything better. From XHR to database access to accessing the Flickr API,
Q is there for you.</li>
<li>There are many libraries that produce and consume Q promises for everything
from file system/database access or RPC to templating. For a list of some of
the more popular ones, see <a href="https://github.com/kriskowal/q/wiki/Libraries">Libraries</a>.</li>
<li>If you want materials that introduce the promise concept generally, and the
below tutorial isn&#39;t doing it for you, check out our collection of
<a href="https://github.com/kriskowal/q/wiki/General-Promise-Resources">presentations, blog posts, and podcasts</a>.</li>
<li>A guide for those <a href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery">coming from jQuery&#39;s <code>$.Deferred</code></a>.</li>
</ul>
<p>We&#39;d also love to have you join the Q-Continuum <a href="https://groups.google.com/forum/#!forum/q-continuum">mailing list</a>.</p>
<h2>Introduction</h2><p>There are many reasons to use promises.  The first reward is that
promises implicitly propagate errors and values downstream.  Consider
this synchronous solution to reading a file and parsing its content.</p>
<pre><code class="language-javascript">var FS = require(&quot;fs&quot;);
var readJsonSync = function (path) {
    return JSON.parse(FS.readSync(path, &quot;utf-8&quot;));
};
</code></pre>
<p>The asynchronous analog would ideally look and behave exactly the same
<em>except</em> it would explicitly mark anywhere it might yield to other
tasks, which is to say, between calling and returning, and reading and
parsing.  Control flow constructs like <code>return</code>, <code>throw</code>, <code>if</code>, <code>for</code>,
<code>break</code> and <code>continue</code> would still work, except asynchronously.
Exceptions, such as the <code>SyntaxError</code> that <code>JSON.parse</code> might throw,
would propagate through the promise graph just as they do through the
synchronous stack.  Forbes Lindesay illustrates the way to this happy
ideal in his presentation, <a href="http://pag.forbeslindesay.co.uk/">“Promises and Generators”</a>.</p>
<pre><code class="language-javascript">var FS = require(&quot;q-io/fs&quot;);
var readJsonPromise = Q.async(function *(path) {
    return JSON.parse(yield FS.read(path));
});
</code></pre>
<p>Explicitly marking yield points makes it possible for users to take
advantage of the invariant that they can arrange for a consistent
internal state between events, and be guaranteed that only they can
alter their state during an event.  Fibers and threads do not provide
this guarantee, so programmers must work with a heightened sense of
caution—their work may be interrupted and their state modified at any
function call boundary for fibers, or at <em>any time at all</em> with threads.</p>
<p>But even without generators, by using promises, we can at least get
exceptions to implicitly propagate asynchronously with very little
noise.</p>
<pre><code class="language-javascript">var FS = require(&quot;q-io/fs&quot;);
function readJsonPromise(path) {
    return FS.read(path).then(JSON.parse);
}
</code></pre>
<p>Compare these solutions to the equivalent using bare callbacks.  It must
use an explicit <code>try</code> block to <code>catch</code> the exception that <code>JSON.parse</code>
might throw and must manually forward all errors to the subscriber.  It
also must take care not to call the subscriber inside the try block,
since this would catch errors thrown by <code>nodeback</code> and throw them back
at <code>nodeback</code> in the catch block.  In general, writing callback-based
functions that handle errors robustly is difficult and error-prone, and
even if you do it right, rather verbose.</p>
<pre><code class="language-javascript">var FS = require(&quot;fs&quot;);
var readJsonWithNodebacks = function (path, nodeback) {
    FS.readFile(path, &quot;utf-8&quot;, function (error, content) {
        var result;
        if (error) {
            return nodeback(error);
        }
        try {
            result = JSON.parse(result);
        } catch (error) {
            return nodeback(error);
        }
        nodeback(null, result);
    });
}
</code></pre>
<p>The second reward for using promises is that they implicitly guarantee
that interfaces you create will be strictly asynchronous.  Oliver
Steele’s <a href="http://blog.osteele.com/posts/2008/04/minimizing-code-paths-in-asychronous-code">Minimizing Code Paths in Asynchronous Code</a> succinctly
captures the issue and Isaac Schlueter’s more recent treatise,
<a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony">Designing APIs for Asynchrony</a>, reframed the edict as “Do Not
Release Zalgo”.</p>
<p>If you are using Q, you can cast any promise, even a <a href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery">jQuery
“promise”</a>, into a well-behaved promise that will not call event
handlers until your event is done.</p>
<pre><code class="language-javascript">var x = 10;
var part1 = Q($.ajax(...))
.then(function () {
    x = 20;
});
var part2 = Q($.ajax(...))
.then(function () {
    x = 30;
});
expect(x).toBe(10); // still, no matter what
</code></pre>
<p>Using promises also preserves the signatures of synchronous functions.
Continuation passing style is an “inversion of control”, where you pass
control forward instead of getting it back when a function returns.
Promises <a href="http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript">un-invert</a> the inversion, cleanly separating the input
arguments from control flow arguments.  This simplifies the use and
creation of API’s, particularly variadic, rest and spread arguments.</p>
<p>Another point to using promises is that multiple subscribers can wait
for a result, and new subscribers can be added even after the result has
been published.  Consider how much simpler it would be to wait for
DOMContentLoaded with promises.  No need to worry about whether the
event has already passed.</p>
<pre><code class="language-javascript">return document.ready.then(setup);
</code></pre>
<p>Promises go on to be a useful primitive for capturing the “causal graph”
of an asynchronous program, providing “long traces” that capture the
stacks from all the events that led to an exception.  Promises are also
useful as proxies for objects in other processes, pipelining messages
over any inter-process message channel.</p>
<p>The point of promises is that they have scouted the way ahead and will
help you avoid set-backs and dead-ends, from simple problems like
synchronizing local work, to more advanced problems <a href="http://scholar.google.com/citations?user=PuP2INoAAAAJ&amp;hl=en&amp;oi=ao">like distributed
robust secure escrow exchange</a>.</p>
<h2>Tutorial</h2><p>Promises have a <code>then</code> method, which you can use to get the eventual
return value (fulfillment) or thrown exception (rejection).</p>
<pre><code class="language-javascript">promiseMeSomething()
.then(function (value) {
}, function (reason) {
});
</code></pre>
<p>If <code>promiseMeSomething</code> returns a promise that gets fulfilled later
with a return value, the first function (the fulfillment handler) will be
called with the value.  However, if the <code>promiseMeSomething</code> function
gets rejected later by a thrown exception, the second function (the
rejection handler) will be called with the exception.</p>
<p>Note that resolution of a promise is always asynchronous: that is, the
fulfillment or rejection handler will always be called in the next turn of the
event loop (i.e. <code>process.nextTick</code> in Node). This gives you a nice
guarantee when mentally tracing the flow of your code, namely that
<code>then</code> will always return before either handler is executed.</p>
<p>In this tutorial, we begin with how to consume and work with promises. We&#39;ll
talk about how to create them, and thus create functions like
<code>promiseMeSomething</code> that return promises, <a href="#the-beginning">below</a>.</p>
<h3>Propagation</h3><p>The <code>then</code> method returns a promise, which in this example, I’m
assigning to <code>outputPromise</code>.</p>
<pre><code class="language-javascript">var outputPromise = getInputPromise()
.then(function (input) {
}, function (reason) {
});
</code></pre>
<p>The <code>outputPromise</code> variable becomes a new promise for the return
value of either handler.  Since a function can only either return a
value or throw an exception, only one handler will ever be called and it
will be responsible for resolving <code>outputPromise</code>.</p>
<ul>
<li><p>If you return a value in a handler, <code>outputPromise</code> will get
fulfilled.</p>
</li>
<li><p>If you throw an exception in a handler, <code>outputPromise</code> will get
rejected.</p>
</li>
<li><p>If you return a <strong>promise</strong> in a handler, <code>outputPromise</code> will
“become” that promise.  Being able to become a new promise is useful
for managing delays, combining results, or recovering from errors.</p>
</li>
</ul>
<p>If the <code>getInputPromise()</code> promise gets rejected and you omit the
rejection handler, the <strong>error</strong> will go to <code>outputPromise</code>:</p>
<pre><code class="language-javascript">var outputPromise = getInputPromise()
.then(function (value) {
});
</code></pre>
<p>If the input promise gets fulfilled and you omit the fulfillment handler, the
<strong>value</strong> will go to <code>outputPromise</code>:</p>
<pre><code class="language-javascript">var outputPromise = getInputPromise()
.then(null, function (error) {
});
</code></pre>
<p>Q promises provide a <code>fail</code> shorthand for <code>then</code> when you are only
interested in handling the error:</p>
<pre><code class="language-javascript">var outputPromise = getInputPromise()
.fail(function (error) {
});
</code></pre>
<p>If you are writing JavaScript for modern engines only or using
CoffeeScript, you may use <code>catch</code> instead of <code>fail</code>.</p>
<p>Promises also have a <code>fin</code> function that is like a <code>finally</code> clause.
The final handler gets called, with no arguments, when the promise
returned by <code>getInputPromise()</code> either returns a value or throws an
error.  The value returned or error thrown by <code>getInputPromise()</code>
passes directly to <code>outputPromise</code> unless the final handler fails, and
may be delayed if the final handler returns a promise.</p>
<pre><code class="language-javascript">var outputPromise = getInputPromise()
.fin(function () {
    // close files, database connections, stop servers, conclude tests
});
</code></pre>
<ul>
<li>If the handler returns a value, the value is ignored</li>
<li>If the handler throws an error, the error passes to <code>outputPromise</code></li>
<li>If the handler returns a promise, <code>outputPromise</code> gets postponed.  The
eventual value or error has the same effect as an immediate return
value or thrown error: a value would be ignored, an error would be
forwarded.</li>
</ul>
<p>If you are writing JavaScript for modern engines only or using
CoffeeScript, you may use <code>finally</code> instead of <code>fin</code>.</p>
<h3>Chaining</h3><p>There are two ways to chain promises.  You can chain promises either
inside or outside handlers.  The next two examples are equivalent.</p>
<pre><code class="language-javascript">return getUsername()
.then(function (username) {
    return getUser(username)
    .then(function (user) {
        // if we get here without an error,
        // the value returned here
        // or the exception thrown here
        // resolves the promise returned
        // by the first line
    })
});
</code></pre>
<pre><code class="language-javascript">return getUsername()
.then(function (username) {
    return getUser(username);
})
.then(function (user) {
    // if we get here without an error,
    // the value returned here
    // or the exception thrown here
    // resolves the promise returned
    // by the first line
});
</code></pre>
<p>The only difference is nesting.  It’s useful to nest handlers if you
need to capture multiple input values in your closure.</p>
<pre><code class="language-javascript">function authenticate() {
    return getUsername()
    .then(function (username) {
        return getUser(username);
    })
    // chained because we will not need the user name in the next event
    .then(function (user) {
        return getPassword()
        // nested because we need both user and password next
        .then(function (password) {
            if (user.passwordHash !== hash(password)) {
                throw new Error(&quot;Can&#39;t authenticate&quot;);
            }
        });
    });
}
</code></pre>
<h3>Combination</h3><p>You can turn an array of promises into a promise for the whole,
fulfilled array using <code>all</code>.</p>
<pre><code class="language-javascript">return Q.all([
    eventualAdd(2, 2),
    eventualAdd(10, 20)
]);
</code></pre>
<p>If you have a promise for an array, you can use <code>spread</code> as a
replacement for <code>then</code>.  The <code>spread</code> function “spreads” the
values over the arguments of the fulfillment handler.  The rejection handler
will get called at the first sign of failure.  That is, whichever of
the received promises fails first gets handled by the rejection handler.</p>
<pre><code class="language-javascript">function eventualAdd(a, b) {
    return Q.spread([a, b], function (a, b) {
        return a + b;
    })
}
</code></pre>
<p>But <code>spread</code> calls <code>all</code> initially, so you can skip it in chains.</p>
<pre><code class="language-javascript">return getUsername()
.then(function (username) {
    return [username, getUser(username)];
})
.spread(function (username, user) {
});
</code></pre>
<p>The <code>all</code> function returns a promise for an array of values.  When this
promise is fulfilled, the array contains the fulfillment values of the original
promises, in the same order as those promises.  If one of the given promises
is rejected, the returned promise is immediately rejected, not waiting for the
rest of the batch.  If you want to wait for all of the promises to either be
fulfilled or rejected, you can use <code>allSettled</code>.</p>
<pre><code class="language-javascript">Q.allSettled(promises)
.then(function (results) {
    results.forEach(function (result) {
        if (result.state === &quot;fulfilled&quot;) {
            var value = result.value;
        } else {
            var reason = result.reason;
        }
    });
});
</code></pre>
<h3>Sequences</h3><p>If you have a number of promise-producing functions that need
to be run sequentially, you can of course do so manually:</p>
<pre><code class="language-javascript">return foo(initialVal).then(bar).then(baz).then(qux);
</code></pre>
<p>However, if you want to run a dynamically constructed sequence of
functions, you&#39;ll want something like this:</p>
<pre><code class="language-javascript">var funcs = [foo, bar, baz, qux];

var result = Q(initialVal);
funcs.forEach(function (f) {
    result = result.then(f);
});
return result;
</code></pre>
<p>You can make this slightly more compact using <code>reduce</code> (a
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">method</a> of arrays introduced in ECMAScript 5):</p>
<pre><code class="language-javascript">return funcs.reduce(function (soFar, f) {
    return soFar.then(f);
}, Q(initialVal));
</code></pre>
<p>Or, you could use the ultra-compact version:</p>
<pre><code class="language-javascript">return funcs.reduce(Q.when, Q());
</code></pre>
<h3>Handling Errors</h3><p>One sometimes-unintuive aspect of promises is that if you throw an
exception in the fulfillment handler, it will not be caught by the error
handler.</p>
<pre><code class="language-javascript">return foo()
.then(function (value) {
    throw new Error(&quot;Can&#39;t bar.&quot;);
}, function (error) {
    // We only get here if &quot;foo&quot; fails
});
</code></pre>
<p>To see why this is, consider the parallel between promises and
<code>try</code>/<code>catch</code>. We are <code>try</code>-ing to execute <code>foo()</code>: the error
handler represents a <code>catch</code> for <code>foo()</code>, while the fulfillment handler
represents code that happens <em>after</em> the <code>try</code>/<code>catch</code> block.
That code then needs its own <code>try</code>/<code>catch</code> block.</p>
<p>In terms of promises, this means chaining your rejection handler:</p>
<pre><code class="language-javascript">return foo()
.then(function (value) {
    throw new Error(&quot;Can&#39;t bar.&quot;);
})
.fail(function (error) {
    // We get here with either foo&#39;s error or bar&#39;s error
});
</code></pre>
<h3>Progress Notification</h3><p>It&#39;s possible for promises to report their progress, e.g. for tasks that take a
long time like a file upload. Not all promises will implement progress
notifications, but for those that do, you can consume the progress values using
a third parameter to <code>then</code>:</p>
<pre><code class="language-javascript">return uploadFile()
.then(function () {
    // Success uploading the file
}, function (err) {
    // There was an error, and we get the reason for error
}, function (progress) {
    // We get notified of the upload&#39;s progress as it is executed
});
</code></pre>
<p>Like <code>fail</code>, Q also provides a shorthand for progress callbacks
called <code>progress</code>:</p>
<pre><code class="language-javascript">return uploadFile().progress(function (progress) {
    // We get notified of the upload&#39;s progress
});
</code></pre>
<h3>The End</h3><p>When you get to the end of a chain of promises, you should either
return the last promise or end the chain.  Since handlers catch
errors, it’s an unfortunate pattern that the exceptions can go
unobserved.</p>
<p>So, either return it,</p>
<pre><code class="language-javascript">return foo()
.then(function () {
    return &quot;bar&quot;;
});
</code></pre>
<p>Or, end it.</p>
<pre><code class="language-javascript">foo()
.then(function () {
    return &quot;bar&quot;;
})
.done();
</code></pre>
<p>Ending a promise chain makes sure that, if an error doesn’t get
handled before the end, it will get rethrown and reported.</p>
<p>This is a stopgap. We are exploring ways to make unhandled errors
visible without any explicit handling.</p>
<h3>The Beginning</h3><p>Everything above assumes you get a promise from somewhere else.  This
is the common case.  Every once in a while, you will need to create a
promise from scratch.</p>
<h4>Using <code>Q.fcall</code></h4><p>You can create a promise from a value using <code>Q.fcall</code>.  This returns a
promise for 10.</p>
<pre><code class="language-javascript">return Q.fcall(function () {
    return 10;
});
</code></pre>
<p>You can also use <code>fcall</code> to get a promise for an exception.</p>
<pre><code class="language-javascript">return Q.fcall(function () {
    throw new Error(&quot;Can&#39;t do it&quot;);
});
</code></pre>
<p>As the name implies, <code>fcall</code> can call functions, or even promised
functions.  This uses the <code>eventualAdd</code> function above to add two
numbers.</p>
<pre><code class="language-javascript">return Q.fcall(eventualAdd, 2, 2);
</code></pre>
<h4>Using Deferreds</h4><p>If you have to interface with asynchronous functions that are callback-based
instead of promise-based, Q provides a few shortcuts (like <code>Q.nfcall</code> and
friends). But much of the time, the solution will be to use <em>deferreds</em>.</p>
<pre><code class="language-javascript">var deferred = Q.defer();
FS.readFile(&quot;foo.txt&quot;, &quot;utf-8&quot;, function (error, text) {
    if (error) {
        deferred.reject(new Error(error));
    } else {
        deferred.resolve(text);
    }
});
return deferred.promise;
</code></pre>
<p>Note that a deferred can be resolved with a value or a promise.  The
<code>reject</code> function is a shorthand for resolving with a rejected
promise.</p>
<pre><code class="language-javascript">// this:
deferred.reject(new Error(&quot;Can&#39;t do it&quot;));

// is shorthand for:
var rejection = Q.fcall(function () {
    throw new Error(&quot;Can&#39;t do it&quot;);
});
deferred.resolve(rejection);
</code></pre>
<p>This is a simplified implementation of <code>Q.delay</code>.</p>
<pre><code class="language-javascript">function delay(ms) {
    var deferred = Q.defer();
    setTimeout(deferred.resolve, ms);
    return deferred.promise;
}
</code></pre>
<p>This is a simplified implementation of <code>Q.timeout</code></p>
<pre><code class="language-javascript">function timeout(promise, ms) {
    var deferred = Q.defer();
    Q.when(promise, deferred.resolve);
    delay(ms).then(function () {
        deferred.reject(new Error(&quot;Timed out&quot;));
    });
    return deferred.promise;
}
</code></pre>
<p>Finally, you can send a progress notification to the promise with
<code>deferred.notify</code>.</p>
<p>For illustration, this is a wrapper for XML HTTP requests in the browser. Note
that a more <a href="https://github.com/montagejs/mr/blob/71e8df99bb4f0584985accd6f2801ef3015b9763/browser.js#L29-L73">thorough</a> implementation would be in order in practice.</p>
<pre><code class="language-javascript">function requestOkText(url) {
    var request = new XMLHttpRequest();
    var deferred = Q.defer();

    request.open(&quot;GET&quot;, url, true);
    request.onload = onload;
    request.onerror = onerror;
    request.onprogress = onprogress;
    request.send();

    function onload() {
        if (request.status === 200) {
            deferred.resolve(request.responseText);
        } else {
            deferred.reject(new Error(&quot;Status code was &quot; + request.status));
        }
    }

    function onerror() {
        deferred.reject(new Error(&quot;Can&#39;t XHR &quot; + JSON.stringify(url)));
    }

    function onprogress(event) {
        deferred.notify(event.loaded / event.total);
    }

    return deferred.promise;
}
</code></pre>
<p>Below is an example of how to use this <code>requestOkText</code> function:</p>
<pre><code class="language-javascript">requestOkText(&quot;http://localhost:3000&quot;)
.then(function (responseText) {
    // If the HTTP response returns 200 OK, log the response text.
    console.log(responseText);
}, function (error) {
    // If there&#39;s an error or a non-200 status code, log the error.
    console.error(error);
}, function (progress) {
    // Log the progress as it comes in.
    console.log(&quot;Request progress: &quot; + Math.round(progress * 100) + &quot;%&quot;);
});
</code></pre>
<h3>The Middle</h3><p>If you are using a function that may return a promise, but just might
return a value if it doesn’t need to defer, you can use the “static”
methods of the Q library.</p>
<p>The <code>when</code> function is the static equivalent for <code>then</code>.</p>
<pre><code class="language-javascript">return Q.when(valueOrPromise, function (value) {
}, function (error) {
});
</code></pre>
<p>All of the other methods on a promise have static analogs with the
same name.</p>
<p>The following are equivalent:</p>
<pre><code class="language-javascript">return Q.all([a, b]);
</code></pre>
<pre><code class="language-javascript">return Q.fcall(function () {
    return [a, b];
})
.all();
</code></pre>
<p>When working with promises provided by other libraries, you should
convert it to a Q promise.  Not all promise libraries make the same
guarantees as Q and certainly don’t provide all of the same methods.
Most libraries only provide a partially functional <code>then</code> method.
This thankfully is all we need to turn them into vibrant Q promises.</p>
<pre><code class="language-javascript">return Q($.ajax(...))
.then(function () {
});
</code></pre>
<p>If there is any chance that the promise you receive is not a Q promise
as provided by your library, you should wrap it using a Q function.
You can even use <code>Q.invoke</code> as a shorthand.</p>
<pre><code class="language-javascript">return Q.invoke($, &#39;ajax&#39;, ...)
.then(function () {
});
</code></pre>
<h3>Over the Wire</h3><p>A promise can serve as a proxy for another object, even a remote
object.  There are methods that allow you to optimistically manipulate
properties or call functions.  All of these interactions return
promises, so they can be chained.</p>
<pre><code>direct manipulation         using a promise as a proxy
--------------------------  -------------------------------
value.foo                   promise.get(&quot;foo&quot;)
value.foo = value           promise.put(&quot;foo&quot;, value)
delete value.foo            promise.del(&quot;foo&quot;)
value.foo(...args)          promise.post(&quot;foo&quot;, [args])
value.foo(...args)          promise.invoke(&quot;foo&quot;, ...args)
value(...args)              promise.fapply([args])
value(...args)              promise.fcall(...args)
</code></pre><p>If the promise is a proxy for a remote object, you can shave
round-trips by using these functions instead of <code>then</code>.  To take
advantage of promises for remote objects, check out <a href="https://github.com/kriskowal/q-connection">Q-Connection</a>.</p>
<p>Even in the case of non-remote objects, these methods can be used as
shorthand for particularly-simple fulfillment handlers. For example, you
can replace</p>
<pre><code class="language-javascript">return Q.fcall(function () {
    return [{ foo: &quot;bar&quot; }, { foo: &quot;baz&quot; }];
})
.then(function (value) {
    return value[0].foo;
});
</code></pre>
<p>with</p>
<pre><code class="language-javascript">return Q.fcall(function () {
    return [{ foo: &quot;bar&quot; }, { foo: &quot;baz&quot; }];
})
.get(0)
.get(&quot;foo&quot;);
</code></pre>
<h3>Adapting Node</h3><p>If you&#39;re working with functions that make use of the Node.js callback pattern,
where callbacks are in the form of <code>function(err, result)</code>, Q provides a few
useful utility functions for converting between them. The most straightforward
are probably <code>Q.nfcall</code> and <code>Q.nfapply</code> (&quot;Node function call/apply&quot;) for calling
Node.js-style functions and getting back a promise:</p>
<pre><code class="language-javascript">return Q.nfcall(FS.readFile, &quot;foo.txt&quot;, &quot;utf-8&quot;);
return Q.nfapply(FS.readFile, [&quot;foo.txt&quot;, &quot;utf-8&quot;]);
</code></pre>
<p>If you are working with methods, instead of simple functions, you can easily
run in to the usual problems where passing a method to another function—like
<code>Q.nfcall</code>—&quot;un-binds&quot; the method from its owner. To avoid this, you can either
use <code>Function.prototype.bind</code> or some nice shortcut methods we provide:</p>
<pre><code class="language-javascript">return Q.ninvoke(redisClient, &quot;get&quot;, &quot;user:1:id&quot;);
return Q.npost(redisClient, &quot;get&quot;, [&quot;user:1:id&quot;]);
</code></pre>
<p>You can also create reusable wrappers with <code>Q.denodeify</code> or <code>Q.nbind</code>:</p>
<pre><code class="language-javascript">var readFile = Q.denodeify(FS.readFile);
return readFile(&quot;foo.txt&quot;, &quot;utf-8&quot;);

var redisClientGet = Q.nbind(redisClient.get, redisClient);
return redisClientGet(&quot;user:1:id&quot;);
</code></pre>
<p>Finally, if you&#39;re working with raw deferred objects, there is a
<code>makeNodeResolver</code> method on deferreds that can be handy:</p>
<pre><code class="language-javascript">var deferred = Q.defer();
FS.readFile(&quot;foo.txt&quot;, &quot;utf-8&quot;, deferred.makeNodeResolver());
return deferred.promise;
</code></pre>
<h3>Long Stack Traces</h3><p>Q comes with optional support for “long stack traces,” wherein the <code>stack</code>
property of <code>Error</code> rejection reasons is rewritten to be traced along
asynchronous jumps instead of stopping at the most recent one. As an example:</p>
<pre><code class="language-js">function theDepthsOfMyProgram() {
  Q.delay(100).done(function explode() {
    throw new Error(&quot;boo!&quot;);
  });
}

theDepthsOfMyProgram();
</code></pre>
<p>usually would give a rather unhelpful stack trace looking something like</p>
<pre><code>Error: boo!
    at explode (/path/to/test.js:3:11)
    at _fulfilled (/path/to/test.js:q:54)
    at resolvedValue.promiseDispatch.done (/path/to/q.js:823:30)
    at makePromise.promise.promiseDispatch (/path/to/q.js:496:13)
    at pending (/path/to/q.js:397:39)
    at process.startup.processNextTick.process._tickCallback (node.js:244:9)
</code></pre><p>But, if you turn this feature on by setting</p>
<pre><code class="language-js">Q.longStackSupport = true;
</code></pre>
<p>then the above code gives a nice stack trace to the tune of</p>
<pre><code>Error: boo!
    at explode (/path/to/test.js:3:11)
From previous event:
    at theDepthsOfMyProgram (/path/to/test.js:2:16)
    at Object.&lt;anonymous&gt; (/path/to/test.js:7:1)
</code></pre><p>Note how you can see the the function that triggered the async operation in the
stack trace! This is very helpful for debugging, as otherwise you end up getting
only the first line, plus a bunch of Q internals, with no sign of where the
operation started.</p>
<p>This feature does come with somewhat-serious performance and memory overhead,
however. If you&#39;re working with lots of promises, or trying to scale a server
to many users, you should probably keep it off. But in development, go for it!</p>
<h2>License</h2><p>Copyright 2009–2013 Kristopher Michael Kowal
MIT License (enclosed)</p>
