<p><code>WeakMap</code> is a collection slated to be introduced to JavaScript with
EcmaScript 6.  It provides a mapping from objects to values, but allows
any entry to be garbage collected if the key is provably lost.</p>
<p>In order for it to be possible that a key is provably lost, weak maps do
not provide a way to access the key list.</p>
<p>This is a Node Packaged Module (NPM) that provides a shim and patcher
for missing or broken WeakMap implementations suitable for use in
Node.js and browsers that provide the EcmaScript 5 property description
interfaces provided that it hosted by a CommonJS loader or bundler like
<a href="https://github.com/substack/node-browserify">Browserify</a>, <a href="https://github.com/montagejs/mr">Montage</a>, <a href="https://github.com/montagejs/mr">Mr</a>, or <a href="https://github.com/montagejs/mop">Mop</a>.</p>
<pre><code>npm install weak-map --save
</code></pre><pre><code class="language-javascript">var WeakMap = require(&quot;weak-map&quot;);
var map = new WeakMap();
var key = {};
map.set(key, &quot;Hello, World!&quot;);
map.get(key) === &quot;Hello, World!&quot;;
key = null;
// &quot;Hello, World!&quot; may be collected
</code></pre>
<p>See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">MDN</a> for the API details.</p>
<p>At time of writing, prototype implementations of <code>WeakMap</code> exist in V8
and Spidermonkey.  The prototype is available in Node.js v0.10 with the
<code>--harmony_collections</code> V8 option.  In v0.8, it was available with
<code>--harmony_weakmaps</code>.  The purpose of this package is to enable
dependees to use weak maps regardless of whether they are implemented by
the underlying engine, albeit in a way that leaks memory in some
non-obvious cases.</p>
<h3>Purpose and limitation</h3><p>This shim depends on and modifies ECMAScript 5 property descriptor related
methods, <code>Object.defineProperty</code>, <code>Object.getOwnPropertyNames</code>,
<code>Object.isExtensible</code>, <code>Object.freeze</code>, and <code>Object.seal</code>.</p>
<p>In a nutshell, the WeakMap shim emulates a WeakMap by adding a hidden
property to the key that associates the weak map with the retained
object. The shim overrides the ECMAScript 5 methods to cover its tracks.</p>
<p>Consider a scenario that only includes a weak map, a key, and a corresponding
value through the weak map. With a proper <code>WeakMap</code>, built into the JavaScript
engine privy to the internals of the garbage collector, the <code>value</code> would be
retained either by the key or the weak map. If <em>either</em> the key or the weak map
are elligible for garbage collection, the value is elligible.</p>
<p>This is in contrast to to a plain <code>Map</code>. In a scenario with a map, a key, and a
value corresponding to the key through the map, neither the key nor the value
will be eligible for garbage collection until the map containing them is
elligible. Thus, if a map is used to establish a relationship between ephemeral
keys and values, it will accumulate garbage.</p>
<p>This shim does its best to approximate a proper <code>WeakMap</code> without an intimate
relationship with the garbage collector. In the same scenario, the value will
become elligible for garbage collection if the key is elligible. Unlike a proper
weak map, if the weak map shim becomes elligible for garbage collection but the
key is retained by something else, the value will be retained. In this scenario,
all operations of the weak map take constant time.</p>
<p>However, if the key is <em>frozen</em>, the weak map retains both the key and the value
and neither are elligible for collection until the weak map becomes elligible
itself. This scenario is unfortunately identical to the behavior of a <code>Map</code>.
Additionally, all operations of the weak map suffer linear time.</p>
<p>As stated by Mark Miller in the code:</p>
<blockquote>
<p>As with true WeakMaps, in this emulation, a key does not retain maps indexed by
that key and (crucially) a map does not retain the keys it indexes. A map by
itself also does not retain the values associated with that map.</p>
<p>However, the values associated with a key in some map are retained so long as
that key is retained and those associations are not overridden. For example,
when used to support membranes, all values exported from a given membrane will
live for the lifetime they would have had in the absence of an interposed
membrane. Even when the membrane is revoked, all objects that would have been
reachable in the absence of revocation will still be reachable, as far as the
GC can tell, even though they will no longer be relevant to ongoing
computation.</p>
<p>The API implemented here is approximately the API as implemented
in FF6.0a1 and agreed to by MarkM, Andreas Gal, and Dave Herman,
rather than the offially approved proposal page.</p>
<p>The first difference between the emulation here and that in FF6.0a1 is the
presence of non enumerable <code>get___</code>, <code>has___</code>, <code>set___</code>, and <code>delete___</code>}
methods on WeakMap instances to represent what would be the hidden internal
properties of a primitive implementation. Whereas the FF6.0a1 WeakMap.prototype
methods require their <code>this</code> to be a genuine WeakMap instance (i.e., an object
of <code>[[Class]]</code> &quot;WeakMap}), since there is nothing unforgeable about the
pseudo-internal method names used here, nothing prevents these emulated
prototype methods from being applied to non-WeakMaps with pseudo-internal
methods of the same names.</p>
<p>Another difference is that our emulated <code>WeakMap.prototype</code> is not itself a
WeakMap. A problem with the current FF6.0a1 API is that WeakMap.prototype is
itself a WeakMap providing ambient mutability and an ambient communications
channel. Thus, if a WeakMap is already present and has this problem,
repairES5.js wraps it in a safe wrappper in order to prevent access to this
channel. (See PATCH_MUTABLE_FROZEN_WEAKMAP_PROTO in repairES5.js).</p>
</blockquote>
<p>This refers to <code>repairES5.js</code> as provided by Google Caja.</p>
<h3>Origin and license</h3><p>The canonical implementation of <code>WeakMap</code> exists in the Google Caja
Subversion repository at <a href="http://google-caja.googlecode.com/svn/trunk">http://google-caja.googlecode.com/svn/trunk</a>.
It was written by Mark S. Miller.  It is released by Google with the
Apache 2.0 license.  This package is maintained by Kris Kowal.</p>
<p>This work began with <a href="http://wiki.ecmascript.org/doku.php?id=harmony:weak_maps">Mark Miller’s proposal</a> for <code>WeakMap</code> to ECMA’s
TC-39, where the JavaScript standard is developed.</p>
