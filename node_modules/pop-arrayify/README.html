<h1>Arrayify</h1><p>This JavaScript package exports an arrayify operator that accepts various types
and coerces them into arrays.</p>
<ul>
<li>Falsy values are coerced to an empty array.</li>
<li>Delegates to the <code>toArray</code> method of collections that implement that method.</li>
<li>Delegates to the <code>forEach</code> method of other collections that implement that
method.</li>
<li>Objects that have a length and numbered properties are coerced into an
array.
Note that passing <code>arguments</code> as an argument to arrayify will probably
deoptimize the calling function.
However, arrayify defends itself from being deoptimized in this fashion by
iterating the given object itself.</li>
<li>Throws an exception for all other cases.</li>
</ul>
<h2>Examples</h2><p>Install</p>
<pre><code>npm install --save pop-arrayify
</code></pre><p>Import the pop-arrayify module.</p>
<pre><code class="language-js">&quot;use strict&quot;;
var arrayify = require(&quot;pop-arrayify&quot;);
</code></pre>
<p>Copies arrays.</p>
<pre><code class="language-js">var array = [1, 2, 3];
var arrayed = arrayify(array);
expect(arrayed).not.toBe(array);
expect(arrayed).toEqual(array);
</code></pre>
<p>Copies objects that implement <code>toArray</code>.</p>
<pre><code class="language-js">var List = require(&quot;collections/list&quot;);
var list = new List([1, 2, 3]);
expect(arrayify(list)).toEqual([1, 2, 3]);
</code></pre>
<p>Copies objects that implement (synchronous) <code>forEach</code>.</p>
<pre><code class="language-js">expect(arrayify({
    forEach: function (callback, thisp) {
        callback.call(thisp, 1);
        callback.call(thisp, 2);
        callback.call(thisp, 3);
    }
})).toEqual([1, 2, 3]);
</code></pre>
<p>Coerces array-like objects:</p>
<pre><code class="language-js">expect(arrayify({
    length: 3,
    0: 1,
    1: 2,
    2: 3
})).toEqual([1, 2, 3]);
</code></pre>
<p>Coerces falsy values to empty arrays.</p>
<pre><code class="language-js">expect(arrayify(null)).toEqual([]);
</code></pre>
<p>Supports no other cases.</p>
<pre><code class="language-js">expect(function () {
    arrayify({});
}).toThrow();
</code></pre>
<h2>Polymorphic operator</h2><p>A well-planned system of objects is beautiful: a system where every meaningful
method for an object has been anticipated in the design.
Inevitably, another layer of architecture introduces a new concept and with it
the temptation to monkey-patch, dunk-punch, or otherwise cover-up the omission.
But reaching backward in time, up through the layers of architecture doesn&#39;t
always compose well, when different levels introduce concepts of the same name
but distinct behavior.</p>
<p>A polymorphic operator is a function that accepts as its first argument an
object and varies its behavior depending on its type.
Such an operator has the benefit of covering for the types from higher layers of
architecture, but defers to the eponymous method name of types yet to be
defined.</p>
<h2>Copyright and License</h2><p>Copyright (c) 2015 Kristopher Michael Kowal and contributors.
All rights reserved.
MIT License.</p>
