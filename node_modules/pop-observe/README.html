<h1>Observable content changes</h1><p>This JavaScript package, suitable for browsers and Node.js, provides a system
for synchronously observing content changes to arrays, objects, and other
instances.
These observers have a common, composable style, expose their internal state for
debugging, and reuse state tracking objects to reduce garbage collection.</p>
<ul>
<li>Changes can be captured before or after they are made.</li>
<li>The last argument of a change notification is the object observed, so a
single handler can service multiple objects.</li>
<li>Handler methods can return a child observer object, which will be implicitly
cancelled before the next change, so observers can be stacked.</li>
<li>Does not alter the Array base type, but promotes array instances to an
ObservableArray when they are observed.</li>
</ul>
<h2>Installation</h2><pre><code>npm install --save pop-observe@2
</code></pre><h2>Examples</h2><p>Observing the length of an array.</p>
<pre><code class="language-js">var array = [];
var observer = O.observePropertyChange(array, &quot;length&quot;, function (length) {
    expect(length).toBe(1);
});
array.push(10);
observer.cancel();
</code></pre>
<p>Observing a property of an ordinary object.</p>
<pre><code class="language-js">var object = {weight: 10};
var observer = O.observePropertyChange(object, &quot;weight&quot;, function (weight) {
    expect(weight).toBe(20);
});
object.weight = 20;
observer.cancel();
</code></pre>
<p>Observing values at indexes.</p>
<pre><code class="language-js">var array = [];
var change;
var handler = {
    handlePropertyChange: function (plus, minus, index, object) {
        change = {
            plus: plus,
            minus: minus,
            index: index,
            object: object
        };
    }
};
var observer0 = O.observePropertyChange(array, 0, handler);
var observer1 = O.observePropertyChange(array, 1, handler);
var observer2 = O.observePropertyChange(array, 2, handler);

array.set(0, 10);
expect(change).toEqual({plus: 10, minus: undefined, index: 0, object: array});

array.set(0, 20);
expect(change).toEqual({plus: 20, minus: 10, index: 0, object: array});

array.set(1, 20);
expect(change).toEqual({plus: 20, minus: undefined, index: 1, object: array});
</code></pre>
<p>Mirroring arrays.</p>
<pre><code class="language-js">var O = require(&quot;pop-observe&quot;);
var swap = require(&quot;pop-swap&quot;);
var array = [];
var mirror = [];
var observer = O.observeRangeChange(array, function (plus, minus, index) {
    swap(mirror, index, minus.length, plus);
});
array.push(1, 2, 3);
array.shift();
array.pop();
expect(mirror).toEqual([2]);
observer.cancel();
</code></pre>
<p>Tracking an array with a plain object.</p>
<pre><code class="language-js">var O = require(&quot;pop-observe&quot;);
var array = [];
var object = {};
var observer = O.observeMapChange(array, function (plus, minus, index, type) {
    if (type === &quot;delete&quot;) {
        delete object[index];
    } else { // type === &quot;create&quot; || type === &quot;update&quot;
        object[index] = plus;
    }
});
array.push(1, 2, 3);
expect(object).toEqual({0: 1, 1: 2, 2: 3});

array.splice(1, 1);
expect(object).toEqual({0: 1, 1: 3});
</code></pre>
<p>Observing a property of a property.
Note that the cancel method gets rid of observers on a.b and b.c.
Note that the b.c observer gets canceled every time b changes.</p>
<pre><code class="language-js">var O = require(&quot;pop-observe&quot;);
var a = {b: {c: 10}};
var value;
var observer = O.observePropertyChange(a, &quot;b&quot;, function (b) {
    value = b.c;
    return O.observePropertyChange(b, &quot;c&quot;, function (c) {
        value = c;
    });
});

a.b = {c: 20};
expect(value).toBe(20);

a.b.c = 30;
expect(value).toBe(30);

observer.cancel();
</code></pre>
<h2>Change notification arguments</h2><ul>
<li>Property change observers dispatch (plus, minus, name, object) change
notifications when the value of a specific, named property changes.
Each observer sees the old value (minus), new value (plus), property name
(name), and the object (object) such that a single property change handler
can service multiple observers.
Observing a property of an ordinary object replaces that property with a
getter and setter.</li>
<li>Range change observers dispatch (plus, minus, index, object) change
notifications when ordered values are removed (captured in a minus array),
then added (captured in the plus array), at a particular index.
Each handler also receives the object observed, so a single handler can
service multiple observers.</li>
<li>Map change observers dispatch (plus, minus, key, object) change
notifications when the value for a specific key in a map has changed.</li>
</ul>
<h2>Behavior on Arrays</h2><ul>
<li>This library does not alter plain JavaScript arrays or the Array prototype.</li>
<li>Observing an array transforms that array into an ObservableArray either by
subverting its prototype or adding properties directly to the instance.
Observable arrays have additional <a href="https://github.com/kriskowal/pop-swap">swap</a> and set methods.</li>
<li>Observing any property change on an array transforms that array into an
observable array and property changes are dispatched for the &quot;length&quot; or any
value by its index.</li>
<li>Observing range changes on an array transforms that array into an observable
array and all of its methods produce these change notifications.</li>
<li>Observing any map change on an array transforms the array into an observable
array and map changes are dispatched for changes to the value at the given
index.</li>
</ul>
<h2>Custom types</h2><p>Arbitrary constructors can mix in or inherit the ObservableObject type to
support the observable interface directly and do not need to provide any further
support.</p>
<pre><code class="language-js">var inherits = require(&quot;util&quot;).inherits;
var ObservableObject = require(&quot;pop-observe/observable-object&quot;);
function Custom() {}
inherits(Custom, ObservableObject);
</code></pre>
<p>Arbitrary constructors can mix in or inherit the ObservableRangeChange type and
must explicitly dispatch change notifications when range change observers are
active.</p>
<pre><code class="language-js">var inherits = require(&quot;util&quot;).inherits;
var ObservableRange = require(&quot;pop-observe/observable-range&quot;);
function Custom() {}
inherits(Custom, ObservableRange);
Customer.prototype.unshift = function unshift(value) {
    if (this.dispatchesRangeChanges) {
        this.dispatchRangeWillChange([value], [], 0);
    }
    // actual work
    if (this.dispatchesRangeChanges) {
        this.dispatchRangeChange([value], [], 0);
    }
};
</code></pre>
<p>This library does not provide any map implementations but provides the
ObservableMap for any to inherit or mix in.</p>
<pre><code class="language-js">var inherits = require(&quot;util&quot;).inherits;
var ObservableMap = require(&quot;pop-observe/observable-map&quot;);
function Custom() {}
inherits(Custom, ObservableMap);
Customer.prototype.delete = function delete(key) {
    var old = this.get(key);
    if (!old) {
        return;
    }
    if (this.dispatchesMapChanges) {
        this.dispatchMapWillChange(&quot;delete&quot;, key, undefined, old);
    }
    // actual work
    if (this.dispatchesMapChanges) {
        this.dispatchMapChange(&quot;delete&quot;, key, undefined, old);
    }
};
</code></pre>
<p>All of thse can be mixed by copying the properties from their prototypes.</p>
<pre><code class="language-js">var ObservableObject = require(&quot;pop-observe/observable-object&quot;);
// Your favorite property copying idiom here
var owns = Object.prototype.hasOwnProperty;
for (var name in ObservableObject.prototype) {
    if (owns.call(ObservableObject.prototype, name)) {
        Customer.prototype[name] = ObservableObject.prototype[name];
    }
}
</code></pre>
<h2>Interface</h2><p>Each type of observer provides before and after methods for observation and
manual dispatch.
For properties, manual dispatch is necessary when a property is hidden behind a
getter and a setter <em>if</em> the value as returned by the getter changes without the
setter ever being invoked.
Arrays require manual dispatch only if the value at a given index changes
without invoking an array mutation method.
For this reason, observable arrays have a <code>set(index, value)</code> method.
All ranged and map collections must implement manual dispatch when their
<code>dispatchesRangeChanges</code> or <code>dispatchesMapChanges</code> properties are true.</p>
<p>Object property change observers</p>
<ul>
<li>observePropertyChange(object, handler, note, capture) -&gt; Observer</li>
<li>observePropertyWillChange(object, handler, note) -&gt; Observer</li>
<li>dispatchPropertyChange(object, name, plus, minus, capture)</li>
<li><p>dispatchPropertyWillChange(object, name, plus, minus)</p>
</li>
<li><p>makePropertyObservable(object, name)</p>
</li>
<li>preventPropertyObserver(object, name)</li>
</ul>
<p>Range change observers</p>
<ul>
<li>observeRangeChange(object, handler, note, capture) -&gt; Observer</li>
<li>observeRangeWillChange(object, handler, note) -&gt; Observer</li>
<li>dispatchRangeChange(object, plus, minus, index, capture)</li>
<li>dispatchRangeWillChange(object, plus, minus, index)</li>
</ul>
<p>Map change observers</p>
<ul>
<li>observeMapChange(object, handler, note, capture) -&gt; Observer</li>
<li>observeMapWillChange(object, handler, note) -&gt; Observer</li>
<li>dispatchMapChange(object, type, key, plus, minus, capture)</li>
<li>dispatchMapWillChange(object, type, key, plus, minus)</li>
</ul>
<p>Observer objects in general</p>
<ul>
<li>Observer.prototype.cancel();</li>
</ul>
<h2>Handlers</h2><p>Handlers may be raw functions, or objects with one or more handler methods.
Observers for different kinds of changes and before and after changes call
different methods of the handler object based on their availability at the time
that the observer is created.
For example, <code>observePropertyWillChange(array, &quot;length&quot;, handler)</code> will create a
property observer that will delegate to the
<code>handler.handleLengthPropertyWillChange(plus, minus, key, object)</code> method, or
just that generic <code>handler.handlePropertyWillChange(plus, minus, key, object)</code>
method if the specific method does not exist.</p>
<ul>
<li>observable object, property observers (plus, minus, key, object)<ul>
<li>after change<ul>
<li>specific: handleProperty<em>Name</em>Change</li>
<li>general: handlePropertyChange</li>
</ul>
</li>
<li>before change<ul>
<li>specific: handleProperty<em>Name</em>WillChange</li>
<li>general: handlePropertyWillChange</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Range changes do not operate on a given property name, but the
<code>observeRangeChange(handler, name, note, capture)</code> method allows you to give the
range change a name, for example, the name of the array observed on a given
object.</p>
<pre><code class="language-js">var handler = {
    handleValuesRangeChange: function (plus, minus, index, object) {
        // ...
    }
};
var observer = repetition.values.observeRangeChange(handler, &quot;values&quot;);
// ...
repetition.values.push(10);
// ...
observer.cancel();
</code></pre>
<ul>
<li>observable range (plus, minus, index, object)<ul>
<li>after change<ul>
<li>specific: handle<em>Name</em>RangeChange</li>
<li>general: handleRangeChange</li>
</ul>
</li>
<li>before change<ul>
<li>specific: handle<em>Name</em>RangeWillChange</li>
<li>general: handleRangeWillChange</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Likewise, <code>observeMapChange(handler, name, note, capture)</code> accepts a name for a
specific handler method.</p>
<ul>
<li>observable map (plus, minus, key, object)<ul>
<li>after change<ul>
<li>specific: handle<em>Name</em>MapChange</li>
<li>general: handleMapChange</li>
</ul>
</li>
<li>before change<ul>
<li>specific: handle<em>Name</em>MapWillChange</li>
<li>general: handleMapWillChange</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Observers</h2><p>Observers are re-usable objects that capture the state of the observer.
Most importantly, they provide the <code>cancel</code> method, which disables the observer
and returns it to a free list for the observer methods to re-use.
They are suitable for run-time inspection of the state of the observer.</p>
<p>They also carry an informational <code>note</code> property, if the caller of the observe
method provided one.
This is intended for use by third parties to provide additional debugging
information about an observer, for example, where the observer came from.</p>
<ul>
<li>PropertyChangeObserver<ul>
<li>object</li>
<li>propertyName</li>
<li>observers</li>
<li>handler</li>
<li>handlerMethodName</li>
<li>childObserver</li>
<li>note</li>
<li>capture</li>
<li>value</li>
</ul>
</li>
<li>RangeChangeObserver<ul>
<li>object</li>
<li>name</li>
<li>observers</li>
<li>handler</li>
<li>handlerMethodName</li>
<li>childObserver</li>
<li>note</li>
<li>capture</li>
</ul>
</li>
<li>MapChangeObserver<ul>
<li>object</li>
<li>name</li>
<li>observers</li>
<li>handler</li>
<li>handlerMethodName</li>
<li>childObserver</li>
<li>note</li>
<li>capture</li>
</ul>
</li>
</ul>
<h2>Implementing observability</h2><p>The <code>pop-observe/observable-object</code>, <code>pop-observe/observable-range</code>, and
<code>pop-observe/observable-map</code> modules export mixable or prototypically
inheritable constructors.
Objects that inherit the observable interface must then dispatch change and will
change notifications if they are being observed, in all of their methods that
change their content.</p>
<ul>
<li>ObservableObject.observePropertyChange(object, handler, note, capture)</li>
<li>ObservableObject.observePropertyWillChange(object, handler, note)</li>
<li>ObservableObject.dispatchPropertyChange(object, name, plus, minus, capture)</li>
<li>ObservableObject.dispatchPropertyWillChange(object, name, plus, minus)</li>
<li>ObservableObject.getPropertyChangeObservers(object, name, capture)</li>
<li>ObservableObject.getPropertyWillChangeObservers(object, name)</li>
<li>ObservableObject.makePropertyObservable(object, name)</li>
<li><p>ObservableObject.preventPropertyObserver(object, name)</p>
</li>
<li><p>ObservableObject.prototype.observePropertyChange(handler, note, capture)</p>
</li>
<li>ObservableObject.prototype.observePropertyWillChange(handler, note)</li>
<li>ObservableObject.prototype.dispatchPropertyChange(name, plus, minus, capture)</li>
<li>ObservableObject.prototype.dispatchPropertyWillChange(name, plus, minus)</li>
<li>ObservableObject.prototype.getPropertyChangeObservers(name, capture)</li>
<li>ObservableObject.prototype.getPropertyWillChangeObservers(name)</li>
<li>ObservableObject.prototype.makePropertyObservable(name)</li>
<li><p>ObservableObject.prototype.preventPropertyObserver(name)</p>
</li>
<li><p>ObservableRange.prototype.observeRangeChange(handler, name, note, capture)</p>
</li>
<li>ObservableRange.prototype.observeRangeWillChange(handler, name, note)</li>
<li>ObservableRange.prototype.dispatchRangeChange(handler, name, note, capture)</li>
<li>ObservableRange.prototype.dispatchRangeWillChange(handler, name, note)</li>
<li><p>ObservableRange.prototype.makeRangeChangesObservable()</p>
</li>
<li><p>ObservableMap.prototype.observeMapChange(handler, name, note, capture)</p>
</li>
<li>ObservableMap.prototype.observeMapWillChange(handler, name, note)</li>
<li>ObservableMap.prototype.dispatchMapChange(type, key, plus, minus, capture)</li>
<li>ObservableMap.prototype.dispatchMapWillChange(type, key, plus, minus)</li>
<li>ObservableMap.prototype.makeMapChangesObservable()</li>
</ul>
<h2>Copyright and License</h2><p>Copyright (c) 2015 Motorola Mobility, Montage Studio, Kristopher Michael Kowal,
and contributors.
All rights reserved.
BSD 3-Clause license.</p>
