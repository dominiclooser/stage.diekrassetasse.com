<h2>v2.0.0 :warning: BACKWARD INCOMPATIBLE</h2><ul>
<li>Iterators have been reimplemented with an ES6 alike interface.</li>
<li>Change observers have been reimplemented with an FRB alike interface.</li>
<li>Removes support for <code>any</code> and <code>all</code>. Use <code>some(Boolean)</code> or
<code>every(Boolean)</code>.</li>
</ul>
<h2>v1.1.0</h2><ul>
<li>Adds an LfuSet, a set useful as a cache with a least-frequently-used
eviction strategy.</li>
<li>Fixes array <code>set</code> and <code>swap</code> for indexes outside the bounds of the existing
array, for both observed and unobserved arrays.</li>
</ul>
<h2>v1.0.2</h2><ul>
<li>Refinements on <code>Object.equals</code> and <code>Object.compare</code>. These are not
necessarily backward compatible, but should be a strict improvement:</li>
<li><code>Object.compare</code> will now return +/- Infinity for inequal strings,
rather than +/- 1 which imply that the distance between any two inequal
strings is always 1. <code>Object.compare</code> for numbers is suitable for finding
the magnitude of the difference as well as the direction.</li>
<li><code>Object.compare</code> and <code>Object.equals</code> will now delegate to either non-null,
non-undefined argument if the other argument is null or undefined.
This allows objects to be constructed that will identify themselves
as equivalent to null or undefined, for example <code>Any</code> types, useful for
testing.</li>
<li><code>Object.equals</code> will only compare object literals derrived directly from the
<code>Object.prototype</code>. All other objects that do not implement <code>compare</code> are
incomparable.</li>
<li>First attempt at fixing <code>set</code>, <code>swap</code>, and <code>splice</code>, later fixed in v1.0.3.
<code>splice</code> must truncate the <code>start</code> index to the array length. <code>swap</code> and
<code>set</code> should not.</li>
</ul>
<h2>v1.0.1</h2><ul>
<li>Bug fix for filter on map-like collections.</li>
</ul>
<h2>v1.0.0 :cake:</h2><ul>
<li>Adds a Deque type based on a circular buffer of exponential
capacity.  (@petkaantonov)</li>
<li>Implements <code>peek</code>, <code>peekBack</code>, <code>poke</code>, and <code>pokeBack</code> on array
shim for Deque “isomorphism”.</li>
<li>Fixes the cases where a change listener is added or removed during
change dispatch. Neither listener will be informed until the next
change. (@asolove)</li>
<li>The property change listener system has been altered such that
once a thunk has been installed on an object, it will not be
removed, in order to avoid churn. Once a property has been
observed, it is likely to be observed again.</li>
<li>Fixes <code>Object.equals</code> for comparing NaN to itself, which should
report <code>true</code> such that collections that use <code>Object.equals</code> to
identify values are able to find <code>NaN</code>. Previously, <code>NaN</code> could
get stuck in a collection permanently.</li>
<li>In abstract, Collections previously identified duck types by
looking only at the prototype chain, ignoring owned properties.
Thus, an object could distinguish a property name that was being
used as a key of a record, from the same property name that was
being used as a method name. To improve performance and to face
the reality that oftentimes an owned property is in fact a method,
Collections no longer observe this distinction. That is, if an
object has a function by the appropriate name, either by ownership
or inheritance, it will be recognized as a method of a duck type.
This particularly affects <code>Object.equals</code>, which should be much
faster now.</li>
<li>Fixes <code>Object.equals</code> such that property for property comparison
between objects only happens if they both descend directly from
<code>Object.prototype</code>. Previously, objects would be thus compared if
they both descended from the same prototype.</li>
<li>Accommodate <em>very</em> large arrays with the <code>swap</code> shim. Previously,
the size of an array swap was limited by the size of the
JavaScript run-time stack. (@francoisfrisch)</li>
<li>Fixes <code>splice</code> on an array when given a negative start index.
(@stuk)</li>
<li>Some methods accept an optional <code>equals</code> or <code>index</code> argument
that may or may not be supported by certain collections, like
<code>find</code> on a <code>SortedSet</code> versus a <code>List</code>. Collections that do not
support this argument will now throw an error instead of silently
ignoring the argument.</li>
<li>Fixes <code>Array#clone</code> cycle detection.</li>
</ul>
<h2>v0.2.2</h2><ul>
<li><code>one</code> now returns a consistent value between changes of a sorted
set.</li>
<li>All collections can now be required using the MontageJS style, as
well as the Node.js style. I reserve the right to withdraw support
for the current MontageJS style if in a future,
backward-incompatible release of Montage migrated to the Node.js
style.</li>
</ul>
<h2>v0.2.1</h2><ul>
<li>Identify Maps with <code>isMap</code> property instead of <code>keys</code>, as ES6
proposes <code>keys</code>, <code>values</code>, and <code>entries</code> methods for arrays.</li>
</ul>
<h2>v0.2.0</h2><ul>
<li>Fixes the enumerability of dispatchesRangeChanges and
dispatchesMapChanges on observable arrays (and others,
incidentally).</li>
<li>List and Set now dispatch valid range changes, at the penalty of
making updates linear when they are made observable.</li>
<li>Adds <code>join</code> method to generic collections.</li>
<li>Fixes a bug in <code>Object.has(object, value)</code>, where it would not
delegate polymorphically to <code>object.has(value)</code></li>
<li>Fixes <code>Object.addEach(object, undefined)</code>, such that it tolerates
the case without throwing an error, like <code>addEach</code> on other
collections.</li>
<li>Fixes change dispatch on LruSet (Paul Koppen) such that a single
change event gets dispatched for both augmentation and truncation.</li>
<li>Fixes change dispatch on Dict, such that the value gets sent on
addition.</li>
</ul>
<h2>v0.1.24</h2><ul>
<li>Factored out WeakMap into separately maintained package.</li>
</ul>
<h2>v0.1.23</h2><ul>
<li>Introduces <code>entries</code> and deprecates <code>items</code> on all map collections.</li>
<li>Fixes Map clear change dispatch.</li>
</ul>
<h2>v0.1.22</h2><ul>
<li>Fixes Set clear change dispatch.</li>
</ul>
<h2>v0.1.21</h2><ul>
<li>Fixes a bug when the <code>plus</code> argument of swap is not an array.</li>
</ul>
<h2>v0.1.20</h2><ul>
<li>Fixes generic map change dispatch on clear.</li>
<li>Adds map change dispatch to Dict.</li>
</ul>
<h2>v0.1.18, v0.1.19</h2><ul>
<li>Require total order on SortedSet</li>
<li>Remove Node v0.6 from supported versions</li>
<li>Add Node v0.10 to supported versions</li>
<li>Fixes <code>hrtime</code> handling (Alexy Kupershtokh)</li>
</ul>
<h2>v0.1.17</h2><p>...</p>
<h2>v0.0.5</h2><ul>
<li>The <code>observable-array</code> and <code>observable-object</code> modules have been
moved to the Functional Reactive Bindings (<code>frb</code>) package as <code>array</code>
and <code>object</code>.</li>
<li><code>List</code>, <code>Set</code>, and <code>SortedSet</code> now support content change
notifications compatibly with <code>frb</code>.</li>
<li>The <code>observable</code> module provides generics methods for observables.
New collections need only call the appropriate dispatch functions if
<code>isObservable</code> is true.</li>
</ul>
