<h1>Iterate</h1><p>This JavaScript package exports an iterator operator that accepts arrays and any
object that implements iterate.</p>
<pre><code>$ npm install --save pop-iterate
</code></pre><p>The iterate operator accepts an array, or object that implements iterate, and
returns an iterator, as described by the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol">iterator protocol</a>, with
some extensions.
The iterations have an index property with the index corresponding to the value.</p>
<pre><code class="language-js">var iterator = iterate([1, 2, 3]);
expect(iterator.next()).toEqual({value: 1, done: false, index: 0});
expect(iterator.next()).toEqual({value: 2, done: false, index: 1});
expect(iterator.next()).toEqual({value: 3, done: false, index: 2});
expect(iterator.next()).toEqual({done: true});
</code></pre>
<p>Iterating on an array, the iterate method accepts optional start, stop, and step
arguments.</p>
<pre><code class="language-js">var array = [1, 2, 3, 4, 5, 6, 7, 8];
var iterator = iterate(array, 1, 6, 2);
expect(iterator.next()).toEqual({value: 2, done: false, index: 1});
expect(iterator.next()).toEqual({value: 4, done: false, index: 3});
expect(iterator.next()).toEqual({value: 6, done: false, index: 5});
expect(iterator.next()).toEqual({done: true});
</code></pre>
<p>The iterate operator also iterates the owned properties of an object.</p>
<pre><code class="language-js">var object = {a: 10, b: 20, c: 30};
var iterator = iterate(object);
expect(iterator.next()).toEqual({value: 10, done: false, index: &quot;a&quot;});
expect(iterator.next()).toEqual({value: 20, done: false, index: &quot;b&quot;});
expect(iterator.next()).toEqual({value: 30, done: false, index: &quot;c&quot;});
expect(iterator.next()).toEqual({done: true});
</code></pre>
<h2>Polymorphic operator</h2><p>A well-planned system of objects is beautiful: a system where every meaningful
method for an object has been anticipated in the design.
Inevitably, another layer of architecture introduces a new concept and with it
the temptation to monkey-patch, dunk-punch, or otherwise cover-up the omission.
But reaching backward in time, up through the layers of architecture doesn&#39;t
always compose well, when different levels introduce concepts of the same name
but distinct behavior.</p>
<p>A polymorphic operator is a function that accepts as its first argument an
object and varies its behavior depending on its type.
Such an operator has the benefit of covering for the types from higher layers of
architecture, but defers to the eponymous method name of types yet to be
defined.</p>
<p>The iterate operator works for arrays and objects.
Any other object can be iterable by implementing the <code>iterate</code> method, and the
iterate operator will defer to it.</p>
<pre><code class="language-js">function Collection() {}
Collection.prototype.iterate = function (start, stop, step) {
};
</code></pre>
<p>This package also exports the individual parts form which it makes iterators.</p>
<pre><code class="language-js">var Iteration = require(&quot;pop-iterate/iteration&quot;);
var ArrayIterator = require(&quot;pop-iterate/array-iterator&quot;);
var ObjectIterator = require(&quot;pop-iterate/object-iterator&quot;);
</code></pre>
