<h1>postcss-value-parser</h1><p><a href="https://travis-ci.org/TrySound/postcss-value-parser"><img src="https://travis-ci.org/TrySound/postcss-value-parser.svg" alt="Travis CI"></a></p>
<p>Transforms CSS declaration values and at-rule parameters into a tree of nodes, and provides a simple traversal API.</p>
<h2>Usage</h2><pre><code class="language-js">var valueParser = require(&#39;postcss-value-parser&#39;);
var cssBackgroundValue = &#39;url(foo.png) no-repeat 40px 73%&#39;;
var parsedValue = valueParser(cssBackgroundValue);
// parsedValue exposes an API described below,
// e.g. parsedValue.walk(..), parsedValue.toString(), etc.
</code></pre>
<p>For example, parsing the value <code>rgba(233, 45, 66, .5)</code> will return the following:</p>
<pre><code class="language-js">{
  nodes: [
    {
      type: &#39;function&#39;,
      value: &#39;rgba&#39;,
      before: &#39;&#39;,
      after: &#39;&#39;,
      nodes: [
        { type: &#39;word&#39;, value: &#39;233&#39; },
        { type: &#39;div&#39;, value: &#39;,&#39;, before: &#39;&#39;, after: &#39; &#39; },
        { type: &#39;word&#39;, value: &#39;45&#39; },
        { type: &#39;div&#39;, value: &#39;,&#39;, before: &#39;&#39;, after: &#39; &#39; },
        { type: &#39;word&#39;, value: &#39;66&#39; },
        { type: &#39;div&#39;, value: &#39;,&#39;, before: &#39; &#39;, after: &#39;&#39; },
        { type: &#39;word&#39;, value: &#39;.5&#39; }
      ]
    }
  ]
}
</code></pre>
<p>If you wanted to convert each <code>rgba()</code> value in <code>sourceCSS</code> to a hex value, you could do so like this:</p>
<pre><code class="language-js">var valueParser = require(&#39;postcss-value-parser&#39;);

var parsed = valueParser(sourceCSS);

// walk() will visit all the of the nodes in the tree,
// invoking the callback for each.
parsed.walk(function (node) {

  // Since we only want to transform rgba() values,
  // we can ignore anything else.
  if (node.type !== &#39;function&#39; &amp;&amp; node.value !== &#39;rgba&#39;) return;

  // We can make an array of the rgba() arguments to feed to a
  // convertToHex() function
  var color = node.nodes.filter(function (node) {
    return node.type === &#39;word&#39;;
  }).map(function (node) {
    return Number(node.value);
  }); // [233, 45, 66, .5]

  // Now we will transform the existing rgba() function node
  // into a word node with the hex value
  node.type = &#39;word&#39;;
  node.value = convertToHex(color);
})

parsed.toString(); // #E92D42
</code></pre>
<h2>Nodes</h2><p>Each node is an object with these common properties:</p>
<ul>
<li><strong>type</strong>: The type of node (<code>word</code>, <code>string</code>, <code>div</code>, <code>space</code>, <code>comment</code>, or <code>function</code>).
Each type is documented below.</li>
<li><strong>value</strong>: Each node has a <code>value</code> property; but what exactly <code>value</code> means
is specific to the node type. Details are documented for each type below.</li>
<li><strong>sourceIndex</strong>: The starting index of the node within the original source
string. For example, given the source string <code>10px 20px</code>, the <code>word</code> node
whose value is <code>20px</code> will have a <code>sourceIndex</code> of <code>5</code>.</li>
</ul>
<h3>word</h3><p>The catch-all node type that includes keywords (e.g. <code>no-repeat</code>),
quantities (e.g. <code>20px</code>, <code>75%</code>, <code>1.5</code>), and hex colors (e.g. <code>#e6e6e6</code>).</p>
<p>Node-specific properties:</p>
<ul>
<li><strong>value</strong>: The &quot;word&quot; itself.</li>
</ul>
<h3>string</h3><p>A quoted string value, e.g. <code>&quot;something&quot;</code> in <code>content: &quot;something&quot;;</code>.</p>
<p>Node-specific properties:</p>
<ul>
<li><strong>value</strong>: The text content of the string.</li>
<li><strong>quote</strong>: The quotation mark surrounding the string, either <code>&quot;</code> or <code>&#39;</code>.</li>
<li><strong>unclosed</strong>: <code>true</code> if the string was not closed properly. e.g. <code>&quot;unclosed string</code>.</li>
</ul>
<h3>div</h3><p>A divider, for example</p>
<ul>
<li><code>,</code> in <code>animation-duration: 1s, 2s, 3s</code></li>
<li><code>/</code> in <code>border-radius: 10px / 23px</code></li>
<li><code>:</code> in <code>(min-width: 700px)</code></li>
</ul>
<p>Node-specific properties:</p>
<ul>
<li><strong>value</strong>: The divider character. Either <code>,</code>, <code>/</code>, or <code>:</code> (see examples above).</li>
<li><strong>before</strong>: Whitespace before the divider.</li>
<li><strong>after</strong>: Whitespace after the divider.</li>
</ul>
<h3>space</h3><p>Whitespace used as a separator, e.g. <code>` occurring twice in</code>border: 1px solid black;`.</p>
<p>Node-specific properties:</p>
<ul>
<li><strong>value</strong>: The whitespace itself.</li>
</ul>
<h3>comment</h3><p>A CSS comment starts with <code>/*</code> and ends with <code>*/</code></p>
<p>Node-specific properties:</p>
<ul>
<li><strong>value</strong>: The comment value without <code>/*</code> and <code>*/</code></li>
<li><strong>unclosed</strong>: <code>true</code> if the comment was not closed properly. e.g. <code>/* comment without an end</code>.</li>
</ul>
<h3>function</h3><p>A CSS function, e.g. <code>rgb(0,0,0)</code> or <code>url(foo.bar)</code>.</p>
<p>Function nodes have nodes nested within them: the function arguments.</p>
<p>Additional properties:</p>
<ul>
<li><strong>value</strong>: The name of the function, e.g. <code>rgb</code> in <code>rgb(0,0,0)</code>.</li>
<li><strong>before</strong>: Whitespace after the opening parenthesis and before the first argument,
e.g. <code>` in</code>rgb(  0,0,0)`.</li>
<li><strong>after</strong>: Whitespace before the closing parenthesis and after the last argument,
e.g. <code>` in</code>rgb(0,0,0  )`.</li>
<li><strong>nodes</strong>: More nodes representing the arguments to the function.</li>
<li><strong>unclosed</strong>: <code>true</code> if the parentheses was not closed properly. e.g. <code>( unclosed-function</code>.</li>
</ul>
<p>Media features surrounded by parentheses are considered functions with an
empty value. For example, <code>(min-width: 700px)</code> parses to these nodes:</p>
<pre><code class="language-js">[
  {
    type: &#39;function&#39;, value: &#39;&#39;, before: &#39;&#39;, after: &#39;&#39;,
    nodes: [
      { type: &#39;word&#39;, value: &#39;min-width&#39; },
      { type: &#39;div&#39;, value: &#39;:&#39;, before: &#39;&#39;, after: &#39; &#39; },
      { type: &#39;word&#39;, value: &#39;700px&#39; }
    ]
  }
]
</code></pre>
<p><code>url()</code> functions can be parsed a little bit differently depending on
whether the first character in the argument is a quotation mark.</p>
<p><code>url( /gfx/img/bg.jpg )</code> parses to:</p>
<pre><code class="language-js">{ type: &#39;function&#39;, sourceIndex: 0, value: &#39;url&#39;, before: &#39; &#39;, after: &#39; &#39;, nodes: [
    { type: &#39;word&#39;, sourceIndex: 5, value: &#39;/gfx/img/bg.jpg&#39; }
] }
</code></pre>
<p><code>url( &quot;/gfx/img/bg.jpg&quot; )</code>, on the other hand, parses to:</p>
<pre><code class="language-js">{ type: &#39;function&#39;, sourceIndex: 0, value: &#39;url&#39;, before: &#39; &#39;, after: &#39; &#39;, nodes: [
     type: &#39;string&#39;, sourceIndex: 5, quote: &#39;&quot;&#39;, value: &#39;/gfx/img/bg.jpg&#39; },
] }
</code></pre>
<h2>API</h2><pre><code>var valueParser = require(&#39;postcss-value-parser&#39;);
</code></pre><h3>valueParser.unit(quantity)</h3><p>Parses <code>quantity</code>, distinguishing the number from the unit. Returns an object like the following:</p>
<pre><code class="language-js">// Given 2rem
{
  number: &#39;2&#39;,
  unit: &#39;rem&#39;
}
</code></pre>
<p>If the <code>quantity</code> argument cannot be parsed as a number, returns <code>false</code>.</p>
<p><em>This function does not parse complete values</em>: you cannot pass it <code>1px solid black</code> and expect <code>px</code> as
the unit. Instead, you should pass it single quantities only. Parse <code>1px solid black</code>, then pass it
the stringified <code>1px</code> node (a <code>word</code> node) to parse the number and unit.</p>
<h3>valueParser.stringify(nodes[, custom])</h3><p>Stringifies a node or array of nodes.</p>
<p>The <code>custom</code> function is called for each <code>node</code>; return a string to override the default behaviour.</p>
<h3>valueParser.walk(nodes, callback[, bubble])</h3><p>Walks each provided node, recursively walking all descendent nodes within functions.</p>
<p>Returning <code>false</code> in the <code>callback</code> will prevent traversal of descendent nodes (within functions).
You can use this feature to for shallow iteration, walking over only the <em>immediate</em> children.
<em>Note: This only applies if <code>bubble</code> is <code>false</code> (which is the default).</em></p>
<p>By default, the tree is walked from the outermost node inwards.
To reverse the direction, pass <code>true</code> for the <code>bubble</code> argument.</p>
<p>The <code>callback</code> is invoked with three arguments: <code>callback(node, index, nodes)</code>.</p>
<ul>
<li><code>node</code>: The current node.</li>
<li><code>index</code>: The index of the current node.</li>
<li><code>nodes</code>: The complete nodes array passed to <code>walk()</code>.</li>
</ul>
<p>Returns the <code>valueParser</code> instance.</p>
<h3>var parsed = valueParser(value)</h3><p>Returns the parsed node tree.</p>
<h3>parsed.nodes</h3><p>The array of nodes.</p>
<h3>parsed.toString()</h3><p>Stringifies the node tree.</p>
<h3>parsed.walk(callback[, bubble])</h3><p>Walks each node inside <code>parsed.nodes</code>. See the documentation for <code>valueParser.walk()</code> above.</p>
<h1>License</h1><p>MIT Â© <a href="mailto:trysound@yandex.ru">Bogdan Chadkin</a></p>
