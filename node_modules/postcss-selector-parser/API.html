<h1>API Documentation</h1><p><em>Please use only this documented API when working with the parser. Methods
not documented here are subject to change at any point.</em></p>
<h2><code>parser</code> function</h2><p>This is the module&#39;s main entry point.</p>
<pre><code class="language-js">var parser = require(&#39;postcss-selector-parser&#39;);
</code></pre>
<h3><code>parser([transform])</code></h3><p>Creates a new <code>processor</code> instance</p>
<pre><code class="language-js">var processor = parser();

// or, with optional transform function
var transform = function (selectors) {
    selectors.eachUniversal(function (selector) {
        selector.remove();
    });
};

var processor = parser(transform)

// Example
var result = processor.process(&#39;*.class&#39;).result;
// =&gt; .class
</code></pre>
<p><a href="#processor">See processor documentation</a></p>
<p>Arguments:</p>
<ul>
<li><code>transform (function)</code>: Provide a function to work with the parsed AST.</li>
</ul>
<h3><code>parser.attribute([props])</code></h3><p>Creates a new attribute selector.</p>
<pre><code class="language-js">parser.attribute({attribute: &#39;href&#39;});
// =&gt; [href]
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&#39;s properties.</li>
</ul>
<h3><code>parser.className([props])</code></h3><p>Creates a new class selector.</p>
<pre><code class="language-js">parser.className({value: &#39;button&#39;});
// =&gt; .button
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&#39;s properties.</li>
</ul>
<h3><code>parser.combinator([props])</code></h3><p>Creates a new selector combinator.</p>
<pre><code class="language-js">parser.combinator({value: &#39;+&#39;});
// =&gt; +
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&#39;s properties.</li>
</ul>
<h3><code>parser.comment([props])</code></h3><p>Creates a new comment.</p>
<pre><code class="language-js">parser.comment({value: &#39;/* Affirmative, Dave. I read you. */&#39;});
// =&gt; /* Affirmative, Dave. I read you. */
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&#39;s properties.</li>
</ul>
<h3><code>parser.id([props])</code></h3><p>Creates a new id selector.</p>
<pre><code class="language-js">parser.id({value: &#39;search&#39;});
// =&gt; #search
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&#39;s properties.</li>
</ul>
<h3><code>parser.nesting([props])</code></h3><p>Creates a new nesting selector.</p>
<pre><code class="language-js">parser.nesting();
// =&gt; &amp;
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&#39;s properties.</li>
</ul>
<h3><code>parser.pseudo([props])</code></h3><p>Creates a new pseudo selector.</p>
<pre><code class="language-js">parser.pseudo({value: &#39;::before&#39;});
// =&gt; ::before
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&#39;s properties.</li>
</ul>
<h3><code>parser.root([props])</code></h3><p>Creates a new root node.</p>
<pre><code class="language-js">parser.root();
// =&gt; (empty)
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&#39;s properties.</li>
</ul>
<h3><code>parser.selector([props])</code></h3><p>Creates a new selector node.</p>
<pre><code class="language-js">parser.selector();
// =&gt; (empty)
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&#39;s properties.</li>
</ul>
<h3><code>parser.string([props])</code></h3><p>Creates a new string node.</p>
<pre><code class="language-js">parser.string();
// =&gt; (empty)
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&#39;s properties.</li>
</ul>
<h3><code>parser.tag([props])</code></h3><p>Creates a new tag selector.</p>
<pre><code class="language-js">parser.tag({value: &#39;button&#39;});
// =&gt; button
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&#39;s properties.</li>
</ul>
<h3><code>parser.universal([props])</code></h3><p>Creates a new universal selector.</p>
<pre><code class="language-js">parser.universal();
// =&gt; *
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&#39;s properties.</li>
</ul>
<h2>Node types</h2><h3><code>node.type</code></h3><p>A string representation of the selector type. It can be one of the following;
<code>attribute</code>, <code>class</code>, <code>combinator</code>, <code>comment</code>, <code>id</code>, <code>nesting</code>, <code>pseudo</code>,
<code>root</code>, <code>selector</code>, <code>string</code>, <code>tag</code>, or <code>universal</code>. Note that for convenience,
these constants are exposed on the main <code>parser</code> as uppercased keys. So for
example you can get <code>id</code> by querying <code>parser.ID</code>.</p>
<pre><code class="language-js">parser.attribute({attribute: &#39;href&#39;}).type;
// =&gt; &#39;attribute&#39;
</code></pre>
<h3><code>node.parent</code></h3><p>Returns the parent node.</p>
<pre><code class="language-js">root.nodes[0].parent === root;
</code></pre>
<h3><code>node.toString()</code>, <code>String(node)</code>, or <code>&#39;&#39; + node</code></h3><p>Returns a string representation of the node.</p>
<pre><code class="language-js">var id = parser.id({value: &#39;search&#39;});
console.log(String(id));
// =&gt; #search
</code></pre>
<h3><code>node.next()</code> &amp; <code>node.prev()</code></h3><p>Returns the next/previous child of the parent node.</p>
<pre><code class="language-js">var next = id.next();
if (next &amp;&amp; next.type !== &#39;combinator&#39;) {
    throw new Error(&#39;Qualified IDs are not allowed!&#39;);
}
</code></pre>
<h3><code>node.replaceWith(node)</code></h3><p>Replace a node with another.</p>
<pre><code class="language-js">var attr = selectors.first.first;
var className = parser.className({value: &#39;test&#39;});
attr.replaceWith(className);
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>node</code>: The node to substitute the original with.</li>
</ul>
<h3><code>node.remove()</code></h3><p>Removes the node from its parent node.</p>
<pre><code class="language-js">if (node.type === &#39;id&#39;) {
    node.remove();
}
</code></pre>
<h3><code>node.clone()</code></h3><p>Returns a copy of a node, detached from any parent containers that the
original might have had.</p>
<pre><code class="language-js">var cloned = parser.id({value: &#39;search&#39;});
String(cloned);

// =&gt; #search
</code></pre>
<h3><code>node.spaces</code></h3><p>Extra whitespaces around the node will be moved into <code>node.spaces.before</code> and
<code>node.spaces.after</code>. So for example, these spaces will be moved as they have
no semantic meaning:</p>
<pre><code class="language-css">      h1     ,     h2   {}
</code></pre>
<p>However, <em>combinating</em> spaces will form a <code>combinator</code> node:</p>
<pre><code class="language-css">h1        h2 {}
</code></pre>
<p>A <code>combinator</code> node may only have the <code>spaces</code> property set if the combinator
value is a non-whitespace character, such as <code>+</code>, <code>~</code> or <code>&gt;</code>. Otherwise, the
combinator value will contain all of the spaces between selectors.</p>
<h3><code>node.source</code></h3><p>An object describing the node&#39;s start/end, line/column source position.</p>
<p>Within the following CSS, the <code>.bar</code> class node ...</p>
<pre><code class="language-css">.foo,
  .bar {}
</code></pre>
<p>... will contain the following <code>source</code> object.</p>
<pre><code class="language-js">source: {
    start: {
        line: 2,
        column: 3
    },
    end: {
        line: 2,
        column: 6
    }
}
</code></pre>
<h3><code>node.sourceIndex</code></h3><p>The zero-based index of the node within the original source string.</p>
<p>Within the following CSS, the <code>.baz</code> class node will have a <code>sourceIndex</code> of <code>12</code>.</p>
<pre><code class="language-css">.foo, .bar, .baz {}
</code></pre>
<h2>Container types</h2><p>The <code>root</code>, <code>selector</code>, and <code>pseudo</code> nodes have some helper methods for working
with their children.</p>
<h3><code>container.nodes</code></h3><p>An array of the container&#39;s children.</p>
<pre><code class="language-js">// Input: h1 h2
selectors.at(0).nodes.length   // =&gt; 3
selectors.at(0).nodes[0].value // =&gt; &#39;h1&#39;
selectors.at(0).nodes[1].value // =&gt; &#39; &#39;
</code></pre>
<h3><code>container.first</code> &amp; <code>container.last</code></h3><p>The first/last child of the container.</p>
<pre><code class="language-js">selector.first === selector.nodes[0];
selector.last === selector.nodes[selector.nodes.length - 1];
</code></pre>
<h3><code>container.at(index)</code></h3><p>Returns the node at position <code>index</code>.</p>
<pre><code class="language-js">selector.at(0) === selector.first;
selector.at(0) === selector.nodes[0];
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>index</code>: The index of the node to return.</li>
</ul>
<h3><code>container.index(node)</code></h3><p>Return the index of the node within its container.</p>
<pre><code class="language-js">selector.index(selector.nodes[2]) // =&gt; 2
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>node</code>: A node within the current container.</li>
</ul>
<h3><code>container.length</code></h3><p>Proxy to the length of the container&#39;s nodes.</p>
<pre><code class="language-js">container.length === container.nodes.length
</code></pre>
<h3><code>container</code> Array iterators</h3><p>The container class provides proxies to certain Array methods; these are:</p>
<ul>
<li><code>container.map === container.nodes.map</code></li>
<li><code>container.reduce === container.nodes.reduce</code></li>
<li><code>container.every === container.nodes.every</code></li>
<li><code>container.some === container.nodes.some</code></li>
<li><code>container.filter === container.nodes.filter</code></li>
<li><code>container.sort === container.nodes.sort</code></li>
</ul>
<p>Note that these methods only work on a container&#39;s immediate children; recursive
iteration is provided by <code>container.walk</code>.</p>
<h3><code>container.each(callback)</code></h3><p>Iterate the container&#39;s immediate children, calling <code>callback</code> for each child.
You may return <code>false</code> within the callback to break the iteration.</p>
<pre><code class="language-js">var className;
selectors.each(function (selector, index) {
    if (selector.type === &#39;class&#39;) {
        className = selector.value;
        return false;
    }
});
</code></pre>
<p>Note that unlike <code>Array#forEach()</code>, this iterator is safe to use whilst adding
or removing nodes from the container.</p>
<p>Arguments:</p>
<ul>
<li><code>callback (function)</code>: A function to call for each node, which receives <code>node</code>
and <code>index</code> arguments.</li>
</ul>
<h3><code>container.walk(callback)</code></h3><p>Like <code>container#each</code>, but will also iterate child nodes as long as they are
<code>container</code> types.</p>
<pre><code class="language-js">selectors.walk(function (selector, index) {
    // all nodes
});
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>callback (function)</code>: A function to call for each node, which receives <code>node</code>
and <code>index</code> arguments.</li>
</ul>
<p>This iterator is safe to use whilst mutating <code>container.nodes</code>,
like <code>container#each</code>.</p>
<h3><code>container.walk</code> proxies</h3><p>The container class provides proxy methods for iterating over types of nodes,
so that it is easier to write modules that target specific selectors. Those
methods are:</p>
<ul>
<li><code>container.walkAttributes</code></li>
<li><code>container.walkClasses</code></li>
<li><code>container.walkCombinators</code></li>
<li><code>container.walkComments</code></li>
<li><code>container.walkIds</code></li>
<li><code>container.walkNesting</code></li>
<li><code>container.walkPseudos</code></li>
<li><code>container.walkTags</code></li>
<li><code>container.walkUniversals</code></li>
</ul>
<h3><code>container.split(callback)</code></h3><p>This method allows you to split a group of nodes by returning <code>true</code> from
a callback. It returns an array of arrays, where each inner array corresponds
to the groups that you created via the callback.</p>
<pre><code class="language-js">// (input) =&gt; h1 h2&gt;&gt;h3
var list = selectors.first.split((selector) =&gt; {
    return selector.type === &#39;combinator&#39;;
});

// (node values) =&gt; [[&#39;h1&#39;, &#39; &#39;], [&#39;h2&#39;, &#39;&gt;&gt;&#39;], [&#39;h3&#39;]]
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>callback (function)</code>: A function to call for each node, which receives <code>node</code>
as an argument.</li>
</ul>
<h3><code>container.prepend(node)</code> &amp; <code>container.append(node)</code></h3><p>Add a node to the start/end of the container. Note that doing so will set
the parent property of the node to this container.</p>
<pre><code class="language-js">var id = parser.id({value: &#39;search&#39;});
selector.append(id);
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>node</code>: The node to add.</li>
</ul>
<h3><code>container.insertBefore(old, new)</code> &amp; <code>container.insertAfter(old, new)</code></h3><p>Add a node before or after an existing node in a container:</p>
<pre><code class="language-js">selectors.walk(function (selector) {
    if (selector.type !== &#39;class&#39;) {
        var className = parser.className({value: &#39;theme-name&#39;});
        selector.parent.insertAfter(selector, className);
    }
});
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>old</code>: The existing node in the container.</li>
<li><code>new</code>: The new node to add before/after the existing node.</li>
</ul>
<h3><code>container.removeChild(node)</code></h3><p>Remove the node from the container. Note that you can also use
<code>node.remove()</code> if you would like to remove just a single node.</p>
<pre><code class="language-js">selector.length // =&gt; 2
selector.remove(id)
selector.length // =&gt; 1;
id.parent       // undefined
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>node</code>: The node to remove.</li>
</ul>
<h3><code>container.removeAll()</code> or <code>container.empty()</code></h3><p>Remove all children from the container.</p>
<pre><code class="language-js">selector.removeAll();
selector.length // =&gt; 0
</code></pre>
<h2>Root nodes</h2><p>A root node represents a comma separated list of selectors. Indeed, all
a root&#39;s <code>toString()</code> method does is join its selector children with a &#39;,&#39;.
Other than this, it has no special functionality and acts like a container.</p>
<h3><code>root.trailingComma</code></h3><p>This will be set to <code>true</code> if the input has a trailing comma, in order to
support parsing of legacy CSS hacks.</p>
<h2>Selector nodes</h2><p>A selector node represents a single compound selector. For example, this
selector string <code>h1 h2 h3, [href] &gt; p</code>, is represented as two selector nodes.
It has no special functionality of its own.</p>
<h2>Pseudo nodes</h2><p>A pseudo selector extends a container node; if it has any parameters of its
own (such as <code>h1:not(h2, h3)</code>), they will be its children. Note that the pseudo
<code>value</code> will always contain the colons preceding the pseudo identifier. This
is so that both <code>:before</code> and <code>::before</code> are properly represented in the AST.</p>
<h2>Attribute nodes</h2><h3><code>attribute.quoted</code></h3><p>Returns <code>true</code> if the attribute&#39;s value is wrapped in quotation marks, false if it is not.
Remains <code>undefined</code> if there is no attribute value.</p>
<pre><code class="language-css">[href=foo] /* false */
[href=&#39;foo&#39;] /* true */
[href=&quot;foo&quot;] /* true */
[href] /* undefined */
</code></pre>
<h3><code>attribute.raws.unquoted</code></h3><p>Returns the unquoted content of the attribute&#39;s value.
Remains <code>undefined</code> if there is no attribute value.</p>
<pre><code class="language-css">[href=foo] /* foo */
[href=&#39;foo&#39;] /* foo */
[href=&quot;foo&quot;] /* foo */
[href] /* undefined */
</code></pre>
<h3><code>attribute.raws.insensitive</code></h3><p>If there is an <code>i</code> specifying case insensitivity, returns that <code>i</code> along with the whitespace
around it.</p>
<pre><code class="language-css">[id=Bar i ] /* &quot; i &quot; */
[id=Bar   i  ] /* &quot;   i  &quot; */
</code></pre>
<h2><code>processor</code></h2><h3><code>process(cssText, [options])</code></h3><p>Processes the <code>cssText</code>, returning the parsed output</p>
<pre><code class="language-js">var processor = parser();

var result = processor.process(&#39; .class&#39;).result;
// =&gt;  .class

// To have the parser normalize whitespace values, utilize the options
var result = processor.process(&#39;  .class  &#39;, {lossless: false}).result;
// =&gt; .class
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>cssText (string)</code>: The css to be parsed.</li>
<li><code>[options] (object)</code>: Process options</li>
</ul>
<p>Options:</p>
<ul>
<li><code>lossless (boolean)</code>: false to normalize the selector whitespace, defaults to true</li>
</ul>
